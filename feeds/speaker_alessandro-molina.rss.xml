<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org</title><link>http://pyvideo.org/</link><description></description><lastBuildDate>Mon, 10 Jul 2017 00:00:00 +0000</lastBuildDate><item><title>ByteCode al supporto dei test per protocolli ed enforcing di best practices</title><link>http://pyvideo.org/pycon-italia-2017/bytecode-al-supporto-dei-test-per-protocolli-ed-enforcing-di-best-practices.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python è un linguaggio interpretato con efficaci strumenti di
introspezione, fino a permetterci di accedere al suo bytecode e vedere
cosa la virtual machine sta per eseguire. Per quanto questa esigenza sia
solitamente molto limitata in ambito di produzione ed uso del software
può venirci utile all’interno delle test suite per verificare che il
codice scritto da terzi o dal noi stessi del domani rispetti ancora dei
protocolli o delle best practices che avevamo presupposto.&lt;/p&gt;
&lt;p&gt;La maggior parte di queste esigenze possono essere soddisfatte anche
tramite l’uso di metaclassi o monkeypatching, ma in alcuni casi è
possibile saltare i check preposti involontariamente (ad esempio
ereditando dalla classe sbagliata nel caso delle metaclassi), mentre la
verifica del byte code ci consente di controllare cosa effettivamente
sarà eseguito, non cosa ci aspettiamo sia eseguito.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alessandro Molina</dc:creator><pubDate>Sat, 08 Apr 2017 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2017-04-08:pycon-italia-2017/bytecode-al-supporto-dei-test-per-protocolli-ed-enforcing-di-best-practices.html</guid><category>quality-assurance</category><category>CPython</category><category>testing</category><category>robustness</category><category>static-typing</category><category>bytecode</category><category>hacking</category><category>compiler</category></item><item><title>TurboGears2 the Framework that scales with you</title><link>http://pyvideo.org/pyconweb-2017/turbogears2-the-framework-that-scales-with-you.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;TurboGears is one of the longest running web frameworks for Python, featured on TalkPythonToMe and with configuration modes ranging from full-stack to microframework.&lt;/p&gt;
&lt;p&gt;Used by big projects like SourceForge.net and RedHat, TG2 might be the right balance between Django and Flask you were looking for.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alessandro Molina</dc:creator><pubDate>Sat, 27 May 2017 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2017-05-27:pyconweb-2017/turbogears2-the-framework-that-scales-with-you.html</guid><category>turbogears</category></item><item><title>Kajiki, the fast and validated template engine you were looking for</title><link>http://pyvideo.org/europython-2017/kajiki-the-fast-and-validated-template-engine-you-were-looking-for.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Being dissatisfied with some of the constraints and complex usage of
Genshi, the TurboGears2 team started working on an alternative that
could solve Genshi speed issues, complex inheritance system and be
backward compatible with genshi templates.&lt;/p&gt;
&lt;p&gt;This is a talk about what lead to the creation of the Kajiki template
engine and what's particular about it.&lt;/p&gt;
&lt;p&gt;The talk will cover:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Comparison on the major template engines available in python
to showcase what's special in Kajiki (validated, xml based)
what was special in Genshi (also lazy evaluated)&lt;/li&gt;
&lt;li&gt;What's a validated template engine and why it's good to have one.&lt;/li&gt;
&lt;li&gt;How Kajiki works, showcase kajiki syntax, it's performances and how
to use it in any python project.&lt;/li&gt;
&lt;li&gt;Why Kajiki is fast, code generation applied and how to write a code
generation template engine like Kajiki and Jinja2 (showcase a simple
50 lines of code template engine that uses code generation).&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alessandro Molina</dc:creator><pubDate>Mon, 10 Jul 2017 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2017-07-10:europython-2017/kajiki-the-fast-and-validated-template-engine-you-were-looking-for.html</guid></item><item><title>Protocols and Practices enforcing in Python through bytecode and inspection</title><link>http://pyvideo.org/europython-2017/protocols-and-practices-enforcing-in-python-through-bytecode-and-inspection.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python is an interpreted development language with powerful introspection
features, up to allow accesso to the byte code itself to see what the
virtual machine is going to do. Reaching down to byte code or low
level inspection is usually a very uncommon need and it's usually only
involved in debugging or understanding the interpreter internals,
but it can be a powerful tool to check that third parties code that
(or the code we will write ourselves in the future) sticks to some
protocols or best practices that are supposed to be in place.&lt;/p&gt;
&lt;p&gt;Most of the needs for this checks are usually performed at execution
time or through techniques like metaclasses and monkeypatching of third
parties code, but in some cases it would be possible to inadvertently
skip those checks or work them around, while verifying the resulting
byte code allows us to check what's really going to be executed and
enforce the required constraints.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alessandro Molina</dc:creator><pubDate>Mon, 10 Jul 2017 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2017-07-10:europython-2017/protocols-and-practices-enforcing-in-python-through-bytecode-and-inspection.html</guid></item><item><title>Post-mortem Debugging e Sviluppo Web</title><link>http://pyvideo.org/pycon-italia-2014/post-mortem-debugging-e-sviluppo-web.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Gli sviluppatori spesso tendono a dimenticare che gli utenti possono essere molto più creativi di loro nell'uso dei loro software. Gli utenti possono essere i migliori tester del nostro software e possiamo sfruttare le loro capacità di portare alla luce problemi a nostro favore se correttamente supportate da strumenti di logging e analisi forense appropriati.&lt;/p&gt;
&lt;p&gt;Gli strumenti di Post-Mortem debugging sono una delle funzionalità più importanti che il nostro ambiente di sviluppo dovrebbe avere, ma spesso sono sottovalutati o sconosciuti.&lt;/p&gt;
&lt;p&gt;Il talk copre alcune delle pratiche più semplici e gli strumenti necessari a metterle in atto per effettuare efficacemente debugging delle problematiche che nascono in una applicazione web sull'ambiente di produzione.&lt;/p&gt;
&lt;p&gt;Alcune delle tematiche coperte riguardano:&lt;/p&gt;
&lt;p&gt;Interactive Debuggers
Post-Mortem Debugging Best Practices
Crash logging and reporting
Performance Monitoring
Parassitaggio dei processi in esecuzione&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alessandro Molina</dc:creator><pubDate>Sat, 24 May 2014 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2014-05-24:pycon-italia-2014/post-mortem-debugging-e-sviluppo-web.html</guid></item><item><title>Applicazioni Web Realtime e Reattive con Python e TurboGears</title><link>http://pyvideo.org/pycon-italia-2014/applicazioni-web-realtime-e-reattive-con-python-e-turbogears.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Le applicazioni web diventano ogni giorno più legate ad aggiornamenti in tempo reale e feedback istantanei all'utente. Nonostante questo sia un ambito dominato da librerie e strumenti Javascript ci sono tecnologie Python che possono facilitarci la vita nel lavorare con componenti riusabili ed aggiornamenti in tempo reale senza bisogno di particolari conoscenze Javascript.&lt;/p&gt;
&lt;p&gt;Il talk copre prevalentemente due tecnologie che possono facilitarci la vita come sviluppatori:&lt;/p&gt;
&lt;p&gt;La prima, ToscaWidgets2 ci permette di creare rapidamente widgets reattivi e riusabili che si aggiornano in modo autonomo quando il loro modello di dati cambia, iniettando e gestendo in autonomia eventuali dipendenze javascript richieste dagli stessi.
La seconda, tgext.socketio ci permette di creare senza fatica applicazioni in grado di comunicare in modo bidirezionale e concorrente con l'utente ed il browser web esattamente come faremmo per qualsiasi altra view/controller del nostro sito.
Il talk spiegherà come essere immediatamente produttivi con queste tecnologie e come iniziare ad usarle tramite la realizzazione di una TodoList multi utente e reattiva che si aggiorna in tempo reale quando un qualsiasi utente effettua modifiche.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alessandro Molina</dc:creator><pubDate>Fri, 23 May 2014 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2014-05-23:pycon-italia-2014/applicazioni-web-realtime-e-reattive-con-python-e-turbogears.html</guid></item><item><title>Kajiki, the fast and validated Template Engine your were looking for</title><link>http://pyvideo.org/pycon-ireland-2016/kajiki-the-fast-and-validated-template-engine-your-were-looking-for.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Being dissatisfied with some of the constraints and complex usage of
Genshi, the TurboGears2 team started working on an alternative that
could solve Genshi speed issues, complex inheritance system and be
backward compatible with genshi templates. This is what lead to the
creation of the Kajiki template engine.&lt;/p&gt;
&lt;p&gt;The talk will cover:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Comparison on the major template engines available in python to
showcase what's special in Kajiki (validated, xml based) what was
special in Genshi (also lazy evaluated)&lt;/li&gt;
&lt;li&gt;What's a validated template engine and why it's good to have one.&lt;/li&gt;
&lt;li&gt;How Kajiki works, showcase kajiki syntax, it's performances and how
to use it in any python project.&lt;/li&gt;
&lt;li&gt;Why Kajiki is fast, code generation applied and how to write a code
generation template engine like Kajiki and Jinja2 (showcase a simple
50 lines of code template engine that uses code generation).&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alessandro Molina</dc:creator><pubDate>Sun, 06 Nov 2016 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2016-11-06:pycon-ireland-2016/kajiki-the-fast-and-validated-template-engine-your-were-looking-for.html</guid></item><item><title>DukyPuy liberarsi dalle catene di NodeJS</title><link>http://pyvideo.org/pycon-italia-2016/dukypuy-liberarsi-dalle-catene-di-nodejs.html</link><description></description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alessandro Molina</dc:creator><pubDate>Mon, 20 Jun 2016 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2016-06-20:pycon-italia-2016/dukypuy-liberarsi-dalle-catene-di-nodejs.html</guid></item><item><title>Why storing files for the web is not as straightforward as you might think.</title><link>http://pyvideo.org/europython-2015/why-storing-files-for-the-web-is-not-as-straightforward-as-you-might-think.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Alessandro Molina - Why storing files for the web is not as straightforward as you might think.
[EuroPython 2015]
[21 July 2015]
[Bilbao, Euskadi, Spain]&lt;/p&gt;
&lt;p&gt;DEPOT ( &lt;a class="reference external" href="http://depot.readthedocs.org/en/latest/"&gt;http://depot.readthedocs.org/en/latest/&lt;/a&gt; ) is a file storage
framework born from the experience on a project that saved a lot of
files on disk, until the day it went online and the customer system
engineering team decided to switch to Heroku, which doesn't support
storing files on disk.&lt;/p&gt;
&lt;p&gt;The talk will cover the facets of a feature &amp;quot;saving files&amp;quot; which has
always been considered straightforward but that can become complex in
the era of cloud deployment and when infrastructure migration happens.&lt;/p&gt;
&lt;p&gt;After exposing the major drawbacks and issues that big projects might
face on short and long terms with file storage the talk will introduce
DEPOT and how it tried to solve most of the issues while providing a
super-easy-to-use interface for developers. We will see how to use
DEPOT to provide attachments on SQLAlchemy or MongoDB and how to
handle problems like migration to a different storage backend and long
term evolution.&lt;/p&gt;
&lt;p&gt;Like SQLAlchemy makes possible to switch your storage on the fly
without touching code, DEPOT aims at making so possible for files and
even use multiple different storages together.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alessandro Molina</dc:creator><pubDate>Thu, 06 Aug 2015 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2015-08-06:europython-2015/why-storing-files-for-the-web-is-not-as-straightforward-as-you-might-think.html</guid></item><item><title>Moving away from NodeJS to a pure python solution for assets</title><link>http://pyvideo.org/europython-2016/moving-away-from-nodejs-to-a-pure-python-solution-for-assets.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Alessandro Molina - Moving away from NodeJS to a pure python solution for assets
[EuroPython 2016]
[20 July 2016]
[Bilbao, Euskadi, Spain]
(&lt;a class="reference external" href="https://ep2016.europython.eu//conference/talks/moving-away-from-nodejs-to-a-pure-python-solution-for-assets"&gt;https://ep2016.europython.eu//conference/talks/moving-away-from-nodejs-to-a-pure-python-solution-for-assets&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;The talk covers the complexity of managing an asset transformation
pipeline through tools like Grunt and NodeJS, especially during
deploy, test suites or when a new development environment has to be
configured from scratch, and showcase how this complexity can be
dodged by using tools like WebAssets and DukPy.&lt;/p&gt;
&lt;p&gt;No more need to keep around two languages, two package management
systems and manage your dependencies between them by youself. Just pip
install your app and have it working.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;When working with WebApplications it is common to rely on an asset
management pipeline to compile scripts, minify css or preprocess
images.&lt;/p&gt;
&lt;p&gt;Most of the tools available today rely on JavaScript to perform those
steps and always forced Python developers to rely on NodeJS to have
grunt perform the pipeline tasks, coffee-script to compile their
CoffeeScript or lessc to build their css. This causes longer setup
times for projects newcomers, complex development environment, working
with two package managers and dependencies that you use once a week
but still need to be there.&lt;/p&gt;
&lt;p&gt;The talk will showcase the DukPy project and focus on how it is
possible to build a pure python asset pipeline relying on DukPy to run
javascript tools and WebAssets framework to perform the most common
tasks that usually Nodejs and tools like Grunt handle for us, greatly
reducing the development environment complexity and making its setup
as simple as ‘pip install’.&lt;/p&gt;
&lt;p&gt;The talk aims at explaining the complexity of managing an asset
transformation pipeline through tools like Grunt, especially during
deploy, test suites or when a new development environment has to be
created, and showcase how this complexity can be dodged by using tools
like WebAssets and DukPy.&lt;/p&gt;
&lt;p&gt;No more need to keep around two languages, two package management
systems and manage your dependencies between them by youself. Just pip
install your app and have it working.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alessandro Molina</dc:creator><pubDate>Mon, 01 Aug 2016 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2016-08-01:europython-2016/moving-away-from-nodejs-to-a-pure-python-solution-for-assets.html</guid></item><item><title>Costruire applicazioni web complesse con le pluggable applications di TurboGears2 in pochi minuti</title><link>http://pyvideo.org/europython-2012/costruire-applicazioni-web-complesse-con-le-plugg.html</link><description>&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2012] Alessandro Molina - 5 JULY 2012 in &amp;quot;Track Big Mac&amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Con la release 2.1 di TurboGears il team di sviluppo ha posto molta
enfasi nel creare un set di strumenti utili al rapid prototyping di
applicazioni web. Questo ha portato alla realizzazione di molte
migliorie all’estensione per la generazione di CRUD ed al supporto per
le applicazioni pluggabili. Padroneggiare questi strumenti può
permetterci di creare applicazioni web complesse senza troppa fatica
riutilizzando parti messe a disposizione da altre applicazioni
pluggabili e creando sezioni amministrative con poche righe di codice
tramite l’uso dell’estensione CRUD sia su SQLAlchemy che MongoDB.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alessandro Molina</dc:creator><pubDate>Fri, 06 Jul 2012 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2012-07-06:europython-2012/costruire-applicazioni-web-complesse-con-le-plugg.html</guid></item><item><title>Baking Beaker perchè sessioni e caching possono ancora convivere</title><link>http://pyvideo.org/pycon-italia-2015/baking-beaker-perche-sessioni-e-caching-possono.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Beaker è probabilmente la più diffusa soluzione cross-framework per la
gestione delle sessioni e della cache nell’ambito web. Nato nel 2005
dagli autori di SQLAlchemy e Pylons è stato sempre mantenuto al fianco
del framework Pylons. Dopo la fine di Pylons a favore di Pyramid il suo
futuro è diventato incerto e, per quanto sia ancora oggi molto usato al
fianco di Bottle, Flask, TurboGears e spesso anche Pyramid, alcuni dei
limiti dovuti all’incompatibilità con Python3 ed alcune scelte
architetturali hanno portato gli utenti ad avvicinarsi a soluzioni
alternative. Nel 2015 la manutenzione di Beaker è stata passata da Ben
Bangert al team di TurboGears che ha riscritto tutta la compatibilità
con Python3 rendendo Beaker un progetto nativo Python3 e risolto alcuni
dei bugs di più lunga data. Il talk mira a mostrare l’esperienza e le
problematiche venute alla luce nei quasi 10 anni di vita del framework
ed illustrare come si intende ridare forza al progetto risolvendo alcuni
dei limiti architetturali pricinpali e quali sono state le scelte
“sbagliate”. Lo scopo è diffondere quali possono essere le problematiche
e le false supposizioni che esistono nell’ambito del caching e della
gestione delle sessioni facendo tesoro delle esperienze fatte dal
progetto Beaker nel corso della sua vita.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alessandro Molina</dc:creator><pubDate>Sat, 30 May 2015 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2015-05-30:pycon-italia-2015/baking-beaker-perche-sessioni-e-caching-possono.html</guid></item><item><title>Messing up with PyMongo for fun and profit</title><link>http://pyvideo.org/pycon-italia-2015/messing-up-with-pymongo-for-fun-and-profit.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;BSON (Binary JSON) è il formato di rappresentazione dei dati usato
internamente da MongoDB per la trasmissione e rappresentazione dei
documenti salvati nel database. Ogni volta che si implementano delle API
HTTP basate su MongoDB il driver (pymongo) riceve i dati in formato BSON
e li deve convertire in un formato comprensibile da Python.
Successivamente questi dati dovranno essere re-encodati nel formato
usato dalle nostre API, solitamente JSON. Per qualcosa come una API REST
che solitamente è solo un proxy ai dati effettivi, l’encoding/decoding
dance può arrivare a pesare pesantemente sulle performance riducendo il
throughput del nostro API Server. La presentazione mira a mostrare come
studiando il funzionamento interno di PyMONGO ed alterandone alcuni
flussi si può evitare in molti casi questo balletto e guadagnare
sensibilmente in numero di richieste al secondo servite dal nostro
ambiente.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alessandro Molina</dc:creator><pubDate>Sat, 30 May 2015 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2015-05-30:pycon-italia-2015/messing-up-with-pymongo-for-fun-and-profit.html</guid></item></channel></rss>